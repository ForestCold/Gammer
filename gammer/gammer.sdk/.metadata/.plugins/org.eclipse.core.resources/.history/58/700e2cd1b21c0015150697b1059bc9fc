#include "xparameters.h"
#include "xgpio.h"
#include "xutil.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "xparameters.h"
#include "xgpio.h"
#include "xutil.h"

/* 不带字库UC1701X 普通IO口驱动*/
const unsigned char ASCII8_16[]=      //可见ASC码 取模表
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18, 0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C, 0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,
0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06, 0x86,0xC6,0x7C,0x18,0x18,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18, 0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00,
0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC, 0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30, 0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,
0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C, 0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF, 0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E, 0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18, 0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0xC6,0xCE,0xD6,0xD6, 0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18, 0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30, 0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06, 0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE, 0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x0E, 0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6, 0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18, 0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6, 0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06, 0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00, 0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00, 0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60, 0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00, 0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06, 0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18, 0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE, 0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE, 0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66, 0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00,
0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0, 0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66, 0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68, 0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68, 0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE, 0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6, 0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18, 0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C, 0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00,
0x00,0x00,0xE6,0x66,0x6C,0x6C,0x78,0x78, 0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60, 0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6, 0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE, 0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00,
0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0xC6, 0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00,
0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60, 0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6, 0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00,
0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C, 0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C, 0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18, 0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6, 0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6, 0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6, 0xD6,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,
0x00,0x00,0xC6,0xC6,0x6C,0x6C,0x38,0x38, 0x6C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00,
0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18, 0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30, 0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30, 0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38, 0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00,
0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C, 0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,
0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,
0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66, 0x66,0x66,0x66,0xDC,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0, 0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC, 0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE, 0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60, 0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC, 0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00,
0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66, 0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18, 0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06, 0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,
0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78, 0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00,
0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18, 0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6, 0xD6,0xD6,0xD6,0xD6,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66, 0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6, 0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66, 0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00,
0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC, 0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00,
0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x62, 0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60, 0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00,
0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30, 0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC, 0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66, 0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6, 0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38, 0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6, 0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00,
0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18, 0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18, 0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18, 0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18, 0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00, };

////上面的脚可以自己修改
//#define  Display  0xAF     //显示开启
//#define  Power    0x2F           //电源全开
//#define  VO       0x24     //对比度调节
//#define  AllPoint 0xA4           //非全屏显示
//#define  ADCset   0xA1            //负向，131-4
//#define  COMset   0xc0            //com0-com63
//#define  ELECTVO  0x81     //亮度调节         调节颜色         不同的模块需要不同的  ELECTSET
//#define  ELECTSET 0x2a           //亮度数值         调节颜色         不同的模块需要不同的        数值
//#define  BIASSET  0xA2    //占空比1/9

u32 lastbit = 0;
u32 lastsw = 0;

//I LOVE U的相关变量
u32 faceDate[] = {0xc3, 0xc3, 0x00, 0x00, 0x18, 0x18, 0x42, 0x3c};
u32 iDate[] = {0xff, 0xff, 0x18, 0x18, 0x18, 0x18, 0xff, 0xff};
u32 loveDate[] = {0x24, 0x7e, 0xff, 0xff, 0x7e, 0x7e, 0x3c, 0x18};
u32 uDate[] = {0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7e, 0x3c};
u32 clearDate[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

//iDate[]
u32 i2Date[] = {0xfe, 0xfe, 0xf0, 0xf0, 0xf0, 0xf0, 0xfe, 0xfe};
u32 i3Date[] = {0xfc, 0xfc, 0xe0, 0xe0, 0xe0, 0xe0, 0xfc, 0xfc};
u32 i4Date[] = {0xf8, 0xf8, 0xc1, 0xc1, 0xc0, 0xc0, 0xf8, 0xf8};
u32 i5Date[] = {0xf0, 0xf1, 0x83, 0x83, 0x81, 0x81, 0xf0, 0xf0};
u32 i6Date[] = {0xe1, 0xe3, 0x07, 0x07, 0x03, 0x03, 0xe1, 0xe0};
u32 i7Date[] = {0xc2, 0xc7, 0x0f, 0x0f, 0x07, 0x07, 0xc3, 0xc1};
u32 i8Date[] = {0x86, 0x8f, 0x1f, 0x1f, 0x0f, 0x0f, 0x07, 0x83};
u32 i9Date[] = {0x0d, 0x1f, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f, 0x06};
u32 i10Date[] = {0x1a, 0x3f, 0x7f, 0x7f, 0x3f, 0x3f, 0x1e, 0x0c};

//loveDate[]
u32 love1Date[] = {0x41, 0xfc, 0xfe, 0xfe, 0xfc, 0xfc, 0x71, 0x30};
u32 love2Date[] = {0x90, 0xf8, 0xfe, 0xfc, 0xf8, 0xf8, 0xf0, 0x60};
u32 love3Date[] = {0x21, 0xf1, 0xf9, 0xf9, 0xf1, 0xf1, 0xe0, 0xc0};
u32 love4Date[] = {0x43, 0xe3, 0xf3, 0xf3, 0xe3, 0xe3, 0xc1, 0x80};
u32 love5Date[] = {0x86, 0xc6, 0xe6, 0xe6, 0xc6, 0xc6, 0x83, 0x01};
u32 love6Date[] = {0x0c, 0x8c, 0xcc, 0xcc, 0x8c, 0x8c, 0x07, 0x03};
u32 love7Date[] = {0x18, 0x18, 0x98, 0x98, 0x18, 0x18, 0x0f, 0x07};
u32 love8Date[] = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1f, 0x0f};
u32 love9Date[] = {0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x3f, 0x1e};

//控制LED板相关变量
u32 laststate;
int i = 0,d;
int PinState;
u32 ZhiLinga = ~(1<<3);
u32 ZhiLingb = ~(1<<2);
u32 ZhiYia = 1<<3;
u32 ZhiYib = 1<<2;

//ZYBO内置按钮
int psb_check;
XGpio b,s;

//贪吃蛇相关变量
int  GameMap[8][8];   //游戏地图
int  key;  //按键保存
int  sum = 2, over = 0, Score = 0;  //蛇的长度, 游戏结束(自吃或碰墙),，分数
int  dx[4] = {0, 0, -1, 1};  //左、右、上、下的方向
int  dy[4] = {-1, 1, 0, 0};
int  timeloop = 999;
u32  GameMapBit[8];
const int Shead = 2;  //蛇头
const int Sbody = 2;  //蛇身
const int Sfood = 1;  //食物
const int Snode = 0;  //'.'在地图上标示为空
void Initial();  //地图的初始化
void Create_Food(); //在地图上随机产生食物
void Show();   //刷新显示地图
void Button();  //取出按键,并判断方向
void Move();   //蛇的移动
void Check_Border();  //检查蛇头是否越界
void Check_Head(int x, int y);   //检查蛇头移动后的位置情况
struct Snake   //贪吃蛇结构体，蛇的每个节点的数据类型
{
	int x, y;  //左边位置
	int now;   //保存当前节点的方向, 0,1,2,3分别为左右上下
}Snake[64];

//主函数相关变量
int mode = 0;
int loop = 0;
int state, finalstate = 0xF0;


void Initial()  //地图的初始化
{
	int i, j;
	//初始化数据
	sum = 2;
	Score = 0;
	over = 0;
	timeloop = 999;
	memset(GameMap, 0, sizeof(GameMap));  //初始化地图全部为空'0'
	//初始化蛇的位置
	GameMap[4][4] = Shead;  GameMap[4][3] = Sbody;
	Snake[0].x = 4;  Snake[0].y = 4;
	Snake[1].x = 4;  Snake[1].y = 3;
	Snake[0].now = -1;

	Create_Food();   //随机产生食物

	xil_printf("Put any button to begin.\r\n",d);

	memset(GameMapBit, 0, sizeof(GameMapBit));
	for(i = 0; i < 8; i++)   //地图显示
	{
		for(j = 0; j < 8; j++)
		{
			if (GameMap[i][j] != 0)
			{
				GameMapBit[i] += 1<<j;
			}
		}
	}
	//显示初始化界面，直到有按钮按下
	key = 0xF0;
	while (key == 0xF0)
	{
		for (d = 0; d < timeloop; d++)
		{
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
					continue;
				}
				else
				{
					xil_printf("Push Buttons Status %x\r\n", key);
					return;
				}
			}

			show_string(7,0,"     L  ",&b,&s);
			show_string(6,0,"  S  H  ",&b,&s);
			show_string(5,0,"G N  F  ",&b,&s);
			show_string(4,0,"A A B&  ",&b,&s);
			show_string(3,0,"M K yL  ",&b,&s);
			show_string(2,0,"E E  Y  ",&b,&s);
			show_string(1,0,"     F  ",&b,&s);
			show_string(0,0,"        ",&b,&s);

			display_once(GameMapBit,&s);
		}
	}


	/*
	Button();  //取出按键,并判断方向

	memset(GameMapBit, 0, sizeof(GameMapBit));
	for(i = 0; i < 8; i++)
	{
		for(j = 0; j < 8; j++)
		{
			if (GameMap[i][j] != 0)
			{
				GameMapBit[i] += 1<<j;
			}
		}
	}
	key = 0;
	for (d = 0; d < timeloop; d++)
	{
		display_once(GameMapBit,&s);
		psb_check = XGpio_DiscreteRead(&b, 1);
		if (psb_check != 0xF0)
		{
			key = psb_check;
		}
	}
	*/
}

void Create_Food()  //在地图上随机产生食物
{
	int fx, fy;
	while(1)
	{
		fx = rand()%8;
		fy = rand()%8;

		if(GameMap[fx][fy] == Snode)  //不能出现在蛇所占有的位置
		{
			GameMap[fx][fy] = Sfood;
			break;
		}
	}
}

void Show()  //刷新显示地图
{
	int i, j;
	if (key == 0xD0)
	{
		return;
	}
	while(1)
	{
		Button();   //先判断按键在移动
		Move();  //移动

		if(over)  //自吃或碰墙即游戏结束
		{
			xil_printf("Game over. Put any button to restart.\r\n",d);
			key = 0xF0;
			while (key == 0xF0)
			{
				for (d = 0; d<999; d++)
				{
					psb_check = XGpio_DiscreteRead(&b, 1);
					if (psb_check != 0xF0)
					{
						key = XGpio_DiscreteRead(&b, 1);
						if (key != psb_check)
						{
							key = 0xF0;
						}
						else if (key == 0xD0)
						{
							return;
						}
						else
						{
							break;
						}
					}

					show_string(7,0,"     L  ",&b,&s);
					show_string(6,0,"  S  H  ",&b,&s);
					show_string(5,0,"G N  F  ",&b,&s);
					show_string(4,0,"A A B&  ",&b,&s);
					show_string(3,0,"M K yL  ",&b,&s);
					show_string(2,0,"E E  Y  ",&b,&s);
					show_string(1,0,"     F  ",&b,&s);
					show_string(0,0,"        ",&b,&s);

					display_once(GameMapBit,&s);
				}
			}
			for(d = 0; d < 1999; d++); //延时一段时间，否则按钮的值会立马传入，导致游戏迅速重新开始
			Initial();
		}


		memset(GameMapBit, 0, sizeof(GameMapBit));
		for(i = 0; i < 8; i++)
		{
			for(j = 0; j < 8; j++)
			{
				if (GameMap[i][j] != 0)
				{
					GameMapBit[i] += 1<<j;
				}
			}
		}
		key = 0xF0;
		for (d = 0; d < timeloop; d++)
		{
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
				else if (key == 0xD0)
				{
					return;
				}
			}

			show_string(7,0,"     L  ",&b,&s);
			show_string(6,0,"  S  H  ",&b,&s);
			show_string(5,0,"G N  F  ",&b,&s);
			show_string(4,0,"A A B&  ",&b,&s);
			show_string(3,0,"M K yL  ",&b,&s);
			show_string(2,0,"E E  Y  ",&b,&s);
			show_string(1,0,"     F  ",&b,&s);
			show_string(0,0,"        ",&b,&s);

			display_once(GameMapBit,&s);
		}
	}
}

void Button()  //取出按键,并判断方向
{
	switch(key)
	{
	//无输入
	case 0xF0:  break;
	//右
	case 0xF1:  if (Snake[0].now != 1 && Snake[0].now != -1) {Snake[0].now = 0;}
			 else {Snake[0].now = 1;}
		break;
	//左
	case 0xF8:  if (Snake[0].now != 0) {Snake[0].now = 1;}
		break;
	//上
	case 0xF4:  if (Snake[0].now != 3) {Snake[0].now = 2;}
		break;
	//下
	case 0xF2:  if (Snake[0].now != 2) {Snake[0].now = 3;}
		break;
	}
}

void Move()   //蛇的移动
{
	int i, x, y;
	int t = sum;  //保存当前蛇的长度

	//记录当前蛇头的位置,并设置为空,蛇头先移动
	x = Snake[0].x;  y = Snake[0].y;  GameMap[x][y] = Snode;
	Snake[0].x = Snake[0].x + dx[ Snake[0].now ];
	Snake[0].y = Snake[0].y + dy[ Snake[0].now ];
	Check_Border();   //蛇头是否越界
	Check_Head(x, y);  //蛇头移动后的位置情况,参数为蛇头的开始位置
	if(sum == t)  //未吃到食物即蛇身移动
	{
		for(i = 1; i < sum; i++)  //要从蛇尾节点向前移动哦,前一个节点作为参照
		{
			if(i == 1)   //尾节点设置为空再移动
			{
				GameMap[ Snake[i].x ][ Snake[i].y ] = Snode;
			}

			if(i == sum-1)  //为蛇头后面的蛇身节点,特殊处理
			{
				Snake[i].x = x;
				Snake[i].y = y;
				Snake[i].now = Snake[0].now;
			}
			else   //其他蛇身即走到前一个蛇身位置
			{
				Snake[i].x = Snake[i+1].x;
				Snake[i].y = Snake[i+1].y;
				Snake[i].now = Snake[i+1].now;
			}

			GameMap[ Snake[i].x ][ Snake[i].y ] = Sbody; //移动后要置为'#'蛇身
		}
	}
}

void Check_Border()  //检查蛇头是否越界
{
	if(Snake[0].x < 0 || Snake[0].x >= 8 || Snake[0].y < 0 || Snake[0].y >= 8)
	{
		over = 1;
	}
}

void Check_Head(int x, int y)  //检查蛇头移动后的位置情况
{

	if(GameMap[ Snake[0].x ][ Snake[0].y ] == Snode)  //为空
	{
		GameMap[ Snake[0].x ][ Snake[0].y ] = Shead;
	}
	else if(GameMap[ Snake[0].x ][ Snake[0].y ] == Sfood)  //为食物
	{
		GameMap[ Snake[0].x ][ Snake[0].y ] = Shead;
		Snake[sum].x = x;   //新增加的蛇身为蛇头后面的那个
		Snake[sum].y = y;
		Snake[sum].now = Snake[0].now;
		GameMap[ Snake[sum].x ][ Snake[sum].y ] = Sbody;
		sum++;
		Score++;
		if (sum % 5 == 0)
		{
			timeloop -= 200;
		}
		Create_Food();  //食物吃完了马上再产生一个食物
	}
	else //吃到自己
	{
		over = 1;
	}
}


/*This function shift a byte in D trigger, the first time we call this function,
we setup the row we want to display, the second time we call this function,
we setup the column we want to display*/
void shiftOut(XGpio *mm, int  a,int  b, u32 c)
{
	   XGpio_DiscreteWrite(mm, 1, laststate & ZhiLinga);
	   laststate = laststate & ZhiLinga;
	   XGpio_DiscreteWrite(mm, 1, laststate & ZhiLingb);
	   laststate = laststate & ZhiLingb;
	   for( i=7; i>=0; i--)
	   {
			XGpio_DiscreteWrite(mm, 1, laststate & ZhiLingb);
		    laststate = laststate & ZhiLingb;
			if(c & (1<<i))
				  PinState = 1;
			else
				  PinState = 0;
			if (PinState == 1)
			{
				  XGpio_DiscreteWrite(mm, 1, ZhiYia | laststate);
				  laststate = ZhiYia | laststate;
			}
		    else
			{
				  XGpio_DiscreteWrite(mm, 1, ZhiLinga & laststate);
				  laststate = ZhiLinga & laststate;
			}
		    XGpio_DiscreteWrite(mm, 1, ZhiYib | laststate);
			laststate = ZhiYib | laststate;
			XGpio_DiscreteWrite(mm, 1, ZhiLinga & laststate);
			laststate = ZhiLinga & laststate;
		}
		XGpio_DiscreteWrite(mm, 1, ZhiLingb & laststate);
		laststate = ZhiLingb & laststate;
}

/*This function display a picture row by row*/
void display_once(u32 mypicture[], XGpio *nn)
{
	    int j;
	    for (j = 0; j< 8; j++)
	    {
			XGpio_DiscreteWrite(nn, 1, 0xfffffffd);
			laststate = 0xfffffffd;
			shiftOut(nn,3,2,~(1<<j));
			shiftOut(nn,3,2,mypicture[j]);
			int n = 1<<1;
			XGpio_DiscreteWrite(nn, 1, n|laststate);
			laststate = n|laststate;
	    }
}

void flashILOVEU(XGpio *ll) //ILOVEU闪烁
{
	for ( d=0; d<999;  d++)
	{
		display_once(iDate,ll);

		psb_check = XGpio_DiscreteRead(&b, 1);
		if (psb_check != 0xF0)
		{
			key = XGpio_DiscreteRead(&b, 1);
			if (key != psb_check)
			{
				key = 0xF0;
			}
		}
	}
	for ( d=0; d<999;  d++)
	{
		display_once(loveDate,ll);
		psb_check = XGpio_DiscreteRead(&b, 1);
		if (psb_check != 0xF0)
		{
			key = XGpio_DiscreteRead(&b, 1);
			if (key != psb_check)
			{
				key = 0xF0;
			}
		}
	}
	for ( d=0; d<999;  d++)
	{
		display_once(uDate,ll);
		psb_check = XGpio_DiscreteRead(&b, 1);
		if (psb_check != 0xF0)
		{
			key = XGpio_DiscreteRead(&b, 1);
			if (key != psb_check)
			{
				key = 0xF0;
			}
		}
	}
}

void moveILOVEU(XGpio *ll) //ILOVEU滚动
{
	  for ( d=0; d<500;  d++)
	  {
		    display_once(iDate,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
		    display_once(i2Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i3Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i4Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i5Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i6Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i7Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i8Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i9Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(i10Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
		    display_once(loveDate,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
		    display_once(love1Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love2Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love3Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love4Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love5Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love6Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love7Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love8Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
	  for ( d=0; d<500;  d++)
	  {
	  		display_once(love9Date,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }

	  for ( d=0; d<500;  d++)
	  {
	  	  	display_once(uDate,ll);
			psb_check = XGpio_DiscreteRead(&b, 1);
			if (psb_check != 0xF0)
			{
				key = XGpio_DiscreteRead(&b, 1);
				if (key != psb_check)
				{
					key = 0xF0;
				}
			}
	  }
}

int hehe (void) //原来的ILOVEU mian函数
{
	    int psb_check;
     	XGpio dip,push;
    	XGpio_Initialize(&push, XPAR_BTNS_4BIT_DEVICE_ID);
	    XGpio_SetDataDirection(&push, 1, 0xffffffff);
    	XGpio_Initialize(&dip, XPAR_SW_4BIT_DEVICE_ID);
    	XGpio_SetDataDirection(&dip, 1, 0x00000000);
    	while (1)
    	{
        	int v = 50;
            psb_check = XGpio_DiscreteRead(&b, 1);
            //xil_printf("Push Buttons Status %x\r\n", psb_check);//button
            switch(psb_check)
            {
                case 1:
                {
                	while(v--)
                	{
                	    flashILOVEU(&dip);
                	}
            	    break;
                }
                case 2:
                {
                	while (v--)
                	{
                         moveILOVEU(&dip);
                    }
                	break;
                }
                default:break;
            }

    	}
}

void delay(int t) //延迟函数
{
	while(t--);
}

void send_8bit_mini12864(unsigned char d, XGpio *b, XGpio *s)  //传8位数据,高位先传
{
	    int i;
        for(i=0;i<8;i++)                    //循环8次,每次发送1个最高位
        {
                //digitalWrite(sck_mini12864,0);       //时钟拉低,一位数据开始
    	        XGpio_DiscreteWrite(s, 1, lastsw&(~1));
    	        lastsw = lastsw&(~1);
                if(d&0x80)                          //与上10000000,最高位如果是1,就数据位就高
                {
                        //digitalWrite(sda_mini12864,1);
                	XGpio_DiscreteWrite(s, 1, lastsw|(1<<4));
                	lastsw = lastsw|(1<<4);
                }
                else                                //与上10000000,最高位如果是0,就数据位就低
                {
                     //digitalWrite(sda_mini12864,0);
                     XGpio_DiscreteWrite(s, 1, lastsw&(~(1<<4)));
                     lastsw = lastsw&(~(1<<4));
                }
                //digitalWrite(sck_mini12864,1);       //一位数据发送完毕,时钟拉高
                XGpio_DiscreteWrite(s, 1, lastsw|1);
                lastsw = lastsw|1;
                d<<=1;                              // d|ddddddd0    抛掉最高位,其余数据左移一位,最低位填0
        }
}

void write_cmd_mini12864(unsigned char cmd, XGpio *b, XGpio *s)  //写命令
{
        //digitalWrite(cs_mini12864,0); //片选拉低,选中芯片
        XGpio_DiscreteWrite( s, 1, ~(1<<7)&lastsw);
        lastsw = ~(1<<7)&lastsw;
        //digitalWrite(rs_mini12864,0); //rs为低,写入命令
        XGpio_DiscreteWrite( s, 1, ~(1<<5)&lastsw);
        lastsw = ~(1<<5)&lastsw;
        send_8bit_mini12864(cmd,b,s);     //写入8位命令
}

void write_dat_mini12864(unsigned char dat, XGpio *b,XGpio *s)  //写数据
{
        //digitalWrite(cs_mini12864,0); //片选拉低,选中芯片
	    XGpio_DiscreteWrite( s, 1, ~(1<<7)&lastsw);
	    lastsw = ~(1<<7)&lastsw;
        //digitalWrite(rs_mini12864,1); //rs为高,写入数据
	    XGpio_DiscreteWrite( s, 1, (1<<5)|lastsw);
	    lastsw = (1<<5)|lastsw;
        send_8bit_mini12864(dat, b, s);          //写入8位数据
}

void mini12864_cl(XGpio *b,XGpio *s)         //清屏,其实就是把所有的地址全部填成0
{
  unsigned char x,y;
  for(y=0;y<8;y++)
  {
    write_cmd_mini12864(0xb0+y, b, s);
    write_cmd_mini12864(0x10, b, s);
    write_cmd_mini12864(0x00, b, s);
    for(x=0;x<132;x++)  write_dat_mini12864(0, b, s);
  }
}

void mini12864_Init( XGpio *b, XGpio *s )   //初始化
{
  //digitalWrite(cs_mini12864,LOW);
  XGpio_DiscreteWrite( s, 1, ~(1<<7)&lastsw);
  lastsw = ~(1<<7)&lastsw;
  //digitalWrite(rst_mini12864,LOW);          //物理重置
  XGpio_DiscreteWrite( s, 1, ~(1<<6)&lastsw);
  lastsw = ~(1<<6)&lastsw;
  delay(200);
  //digitalWrite(rst_mini12864,HIGH);
  XGpio_DiscreteWrite( s, 1, (1<<6)|lastsw);
  lastsw = (1<<6)|lastsw;
  delay(1000);
  write_cmd_mini12864(0xe2, b, s);                //软件重置
  delay(200);

//以下为初始设置,具体请参考数据手册

  write_cmd_mini12864(0x24,b, s);//对比度
  write_cmd_mini12864(0xa2,b, s);//BR=1/9
  write_cmd_mini12864(0xa0,b, s);//set seg direction
  write_cmd_mini12864(0xc8,b, s);//set com direction
  write_cmd_mini12864(0x2f,b, s);//set power control
  write_cmd_mini12864(0x40,b, s);//set scroll line
  write_cmd_mini12864(0x81,b, s);//SET ELECTRONIC VOLUME
  write_cmd_mini12864(0x20,b, s);//set pm: 通过改变这里的数值来改变电压
  //write_cmd(0xa6);//set inverse display           a6 off, a7 on
  //write_cmd(0xa4);//set all pixel on
  write_cmd_mini12864(0xaf,b, s);//开显示

  mini12864_cl(b, s);  //清屏
}

void write_add(unsigned char p, unsigned char l, XGpio *b, XGpio *s)  //页列转换
{
  write_cmd_mini12864(0xb0+p,b, s);                         //先给页数据 0-7,从上到下,页码是直接读取8位数据作为地址
  write_cmd_mini12864(0x10+(8*l/16),b, s);        //再是列 0-127,从左到右,列是先读取高四位，后读取低四位
  write_cmd_mini12864(0x00+(8*l%16),b, s);   //低四位
}

void show_string(unsigned char p, unsigned char l,char  *string, XGpio *b,XGpio *s)   //在第p页的l列
{                                                                                                                                        //显示一个字符串(数组中的元素)
    unsigned int X,i=0;
    write_add(p,l,b, s);    //页列转换函数
    int j;
    while(string[i++])               //判断是否为空
    {
        X=(string[i-1]-32)*16;           //将string中的元素(ASC码)匹配到预先写好的ASC数组之中
        for(j=0;j<16;j++) write_dat_mini12864(ASCII8_16[X++],b, s);         //发显示数据
    }
}

void show_number(unsigned char p, unsigned char l,unsigned int d, XGpio *b,XGpio *s)   //在第p页的l列
{                                                                                                                                        //显示一个字数字
  char ss[8];
  unsigned char m;
  m=0;
  do      //将d分离到数组s中
  {
    ss[m]=d%10;
    m++;
    d=d/10;
  }while(d);//此时m就是d的位数

   unsigned int X;
   write_add(p,l,b, s);                    //页列转换函数
   int z;
   for(z=m;z>0;z--)               //循环m次,没就是数字的位数
   {
    X=(ss[z-1]+48-32)*16;           //由于此时数组中的并非ASC码,而是真真的数字,所以转换时候系数不同
    int j;
    for(j=0;j<16;j++) write_dat_mini12864(ASCII8_16[X++],b, s);         //发显示数据
   }
}


int main(void)
{
	XGpio_Initialize(&b, XPAR_BTNS_4BIT_DEVICE_ID);
	XGpio_SetDataDirection(&b, 1, 0xffffffff);
	XGpio_Initialize(&s, XPAR_SW_4BIT_DEVICE_ID);
	XGpio_SetDataDirection(&s, 1, 0x00000000);
	mini12864_Init(&b,&s);

	while(1)
	{
		if (key == 0xD0)
		{
			mode++;
			if (mode == 4)
			{
				mode = 1;
			}
		}

		key = 0xF0;
		if (mode == 0)
		{
			while(1)
			{
				show_string(7,0,"W    L  ",&b,&s);
				show_string(6,0,"E G  HC ",&b,&s);
				show_string(5,0,"L A  FHG",&b,&s);
				show_string(4,0,"CTM B&OA",&b,&s);
				show_string(3,0,"OOM yLSM",&b,&s);
				show_string(2,0,"M E  YEE",&b,&s);
				show_string(1,0,"E R  F  ",&b,&s);
				show_string(0,0,"        ",&b,&s);

				psb_check = XGpio_DiscreteRead(&b, 1);
				if (psb_check != 0xF0)
				{
					key = XGpio_DiscreteRead(&b, 1);
					if (key != psb_check)
					{
						key = 0xF0;
					}
					if (key == 0xD0)
					{
						break;
					}
				}
			}
		}
		else if (mode == 1)
		{
			while(1)
			{
				flashILOVEU(&s);

				show_string(7,0,"  I  L  ",&b,&s);
				show_string(6,0,"F    H  ",&b,&s);
				show_string(5,0,"L L  F  ",&b,&s);
				show_string(4,0,"A O B&  ",&b,&s);
				show_string(3,0,"S V yL  ",&b,&s);
				show_string(2,0,"H E  Y  ",&b,&s);
				show_string(1,0,"     F  ",&b,&s);
				show_string(0,0,"  U     ",&b,&s);

				if (key == 0xD0)
				{
					break;
				}
			}
		}
		else if (mode == 2)
		{
			while(1)
			{
				moveILOVEU(&s);

				show_string(7,0,"  I  L  ",&b,&s);
				show_string(6,0,"     H  ",&b,&s);
				show_string(5,0,"M L  F  ",&b,&s);
				show_string(4,0,"O O B&  ",&b,&s);
				show_string(3,0,"V V yL  ",&b,&s);
				show_string(2,0,"E E  Y  ",&b,&s);
				show_string(1,0,"     F  ",&b,&s);
				show_string(0,0,"  U     ",&b,&s);

				if (key == 0xD0)
				{
					break;
				}
			}
		}
		else if (mode == 3)
		{
			while(1)
			{
				Initial();
				Show();
				if (key == 0xD0)
				{
					break;
				}
			}
		}
	}
}

int TanChiShe() //原贪吃蛇main函数
{
	XGpio_Initialize(&s, XPAR_BTNS_4BIT_DEVICE_ID);
	XGpio_SetDataDirection(&s, 1, 0xffffffff);
	XGpio_Initialize(&b, XPAR_SW_4BIT_DEVICE_ID);
	XGpio_SetDataDirection(&b, 1, 0x00000000);

	Initial();
	Show();
	return 0;
}

